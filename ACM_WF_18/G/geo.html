<!DOCTYPE html>
<html>
<head>
  <script src="https://lukakalinovcic.github.io/geodeb/main.js"></script>
</head>
<body>
  <div id="rootElement"></div>
</body>
<script type="text/javascript">
resourcePath = 'https://lukakalinovcic.github.io/geodeb/';
jsonData = 
{
  "source_code": [
    "#include <bits/stdc++.h>\u000a",
    "#include \u0022geodeb.h\u0022\u000a",
    "\u000a",
    "#define ld long double\u000a",
    "#define sf scanf\u000a",
    "#define pf printf\u000a",
    "#define pb push_back\u000a",
    "#define PI ( acos(-1.0) )\u000a",
    "#define IN freopen(\u0022input.txt\u0022,\u0022r\u0022,stdin)\u000a",
    "#define OUT freopen(\u0022output.txt\u0022,\u0022w\u0022,stdout)\u000a",
    "#define FOR(i,a,b) for(int i=a ; i<=b ; i++)\u000a",
    "#define FORD(i,a,b) for(int i=a ; i>=b ; i--)\u000a",
    "#define INF 1000000000\u000a",
    "#define ll long long int\u000a",
    "#define eps (1e-9)\u000a",
    "#define sq(x) ( (x)*(x) )\u000a",
    "#define all(x) x.begin(),x.end()\u000a",
    "#define flog2(n) 64 - __builtin_clzll(n) - 1\u000a",
    "#define popcnt(n) __builtin_popcountll(n)\u000a",
    "\u000a",
    "using namespace std;\u000a",
    "\u000a",
    "typedef pair < int, int > pii;\u000a",
    "typedef pair < ll, ll > pll;\u000a",
    "\u000a",
    "struct Point {\u000a",
    "    long double x, y;\u000a",
    "    Point (long double x = 0, long double y = 0): x(x), y(y){}\u000a",
    "    Point operator+(const Point& a) const{\u000a",
    "        return {x + a.x, y + a.y};\u000a",
    "    }\u000a",
    "    Point operator-(const Point& a) const{\u000a",
    "        return {x - a.x, y - a.y};\u000a",
    "    }\u000a",
    "    long double operator*(const Point& a) const{\u000a",
    "        return x * a.x + y * a.y;\u000a",
    "    }\u000a",
    "    Point operator*(long double c) const {\u000a",
    "        return {x * c, y * c};\u000a",
    "    }\u000a",
    "    bool operator<(const Point&a) {\u000a",
    "        if (x == a.x) return y < a.y;\u000a",
    "        return x < a.x;\u000a",
    "    }\u000a",
    "    bool operator==(const Point&a) {\u000a",
    "        return (x == a.x && y == a.y);\u000a",
    "    }\u000a",
    "};\u000a",
    "\u000a",
    "long double cross(const Point& A, const Point& B) {\u000a",
    "    return A.x * B.y - A.y * B.x;\u000a",
    "}\u000a",
    "long double cross(const Point&A, const Point& B, const Point& C) {\u000a",
    "    return cross(A - C, B - C);\u000a",
    "}\u000a",
    "long double abs(const Point& A) {\u000a",
    "    return sqrt(sq(A.x) + sq(A.y));\u000a",
    "}\u000a",
    "\u000a",
    "bool inCircle(Point a, Point b, Point c, Point d) {\u000a",
    "    b = b - a;\u000a",
    "    c = c - a;\u000a",
    "    d = d - a;\u000a",
    "    if (cross(b, c) < 0) swap(b, c);\u000a",
    "    long double m[3][3] = {\u000a",
    "        {b.x, b.y, b*b},\u000a",
    "        {c.x, c.y, c*c},\u000a",
    "        {d.x, d.y, d*d}\u000a",
    "    };\u000a",
    "\u000a",
    "    long double det = m[0][0] * (m[1][1]*m[2][2] - m[1][2]*m[2][1])\u000a",
    "               + m[0][1] * (m[1][2]*m[2][0] - m[1][0]*m[2][2])\u000a",
    "               + m[0][2] * (m[1][0]*m[2][1] - m[1][1]*m[2][0]);\u000a",
    "    return det < -eps;\u000a",
    "}\u000a",
    "\u000a",
    "bool intersect(Point a, Point b, Point c, Point d) {\u000a",
    "    return cross(b, c, a) * cross(b, d, a) < 0 and\u000a",
    "        cross(d, a, c) * cross(d, b, c) < 0;\u000a",
    "}\u000a",
    "\u000a",
    "\u000a",
    "struct Line {\u000a",
    "    long double a, b, c;\u000a",
    "    Line(long double a, long double b, long double c): a(a), b(b), c(c){}\u000a",
    "    Line(Point A, Point B) {\u000a",
    "        a = B.y - A.y;\u000a",
    "        b = A.x - B.x;\u000a",
    "        c = -(a * A.x + b * A.y);\u000a",
    "    }\u000a",
    "};\u000a",
    "\u000a",
    "bool areParallel(Line l1, Line l2) {\u000a",
    "    return fabs(l1.a * l2.b - l1.b * l2.a) < eps;\u000a",
    "}\u000a",
    "bool areIntersect(Line l1, Line l2, Point& p) {\u000a",
    "    if (areParallel(l1, l2)) return 0;\u000a",
    "    long double dx = l1.b * l2.c - l2.b * l1.c;\u000a",
    "    long double dy = l1.c * l2.a - l2.c * l1.a;\u000a",
    "    long double d = l1.a * l2.b - l2.a * l1.b;\u000a",
    "    p = {dx / d, dy / d};\u000a",
    "    return 1;\u000a",
    "}\u000a",
    "\u000a",
    "Point center(Point A, Point B, Point C) {\u000a",
    "    B = B - A;\u000a",
    "    C = C - A;\u000a",
    "    Line l1 = {2 * B.x, 2 * B.y, -sq(B.x) - sq(B.y)};\u000a",
    "    Line l2 = {2 * C.x, 2 * C.y, -sq(C.x) - sq(C.y)};\u000a",
    "    Point O;\u000a",
    "    assert(areIntersect(l1, l2, O));\u000a",
    "    O = O + A;\u000a",
    "    return O;\u000a",
    "}\u000a",
    "\u000a",
    "\u000a",
    "const long double EPS = eps;\u000a",
    "\u000a",
    "struct Triangulation {\u000a",
    "    static const int MXN = 1e5+5;\u000a",
    "    long double MAXC = 10000;\u000a",
    "\u000a",
    "    int N;\u000a",
    "    vector<int> ord;\u000a",
    "    vector<Point> pts, ordPts, voronoiVertices;\u000a",
    "    set<int> E[MXN];\u000a",
    "    map<pair<int, int>, pair<Point, Point>> voronoiEdges;\u000a",
    "\u000a",
    "    void addBoundary(vector<Point>& p) {\u000a",
    "        p.push_back({-2 * MAXC, -2 * MAXC});\u000a",
    "        p.push_back({-2 * MAXC, 2 * MAXC});\u000a",
    "        p.push_back({2 * MAXC, -2 * MAXC});\u000a",
    "        p.push_back({2 * MAXC, 2 * MAXC});\u000a",
    "    }\u000a",
    "    // 0-index, return a vector of triangle\u000a",
    "    vector<vector<int>> solve(vector<Point> p) {\u000a",
    "        ordPts = p;\u000a",
    "        addBoundary(p);\u000a",
    "        N = (int)p.size();\u000a",
    "        ord.resize(N);\u000a",
    "        for (int i=0; i<N; i++) {\u000a",
    "            E[i].clear();\u000a",
    "            ord[i] = i;\u000a",
    "        }\u000a",
    "        sort(all(ord), [&p](int i, int j) {\u000a",
    "            return p[i] < p[j];\u000a",
    "        });\u000a",
    "\u000a",
    "        pts.resize(N);\u000a",
    "        for (int i=0; i<N; i++) pts[i] = p[ord[i]];\u000a",
    "        go(0, N);\u000a",
    "\u000a",
    "        vector<vector<int>> res(N);\u000a",
    "        for (int i=0; i<N; i++) {\u000a",
    "            for (auto x: E[i]) {\u000a",
    "                res[i].push_back(x);\u000a",
    "            }\u000a",
    "        }\u000a",
    "        vector<vector<int>> triangles = getTriangles(res);\u000a",
    "        res.clear();\u000a",
    "        getVoronoiEdges(triangles);\u000a",
    "        \u000a",
    "        // remove boundary\u000a",
    "        for (auto t: triangles) {\u000a",
    "            int maxVal = 0;\u000a",
    "            for (auto i: t) maxVal = max(maxVal, ord[i]);\u000a",
    "            if (maxVal < ordPts.size()) {\u000a",
    "                voronoiVertices.push_back(center(pts[t[0]], pts[t[1]], pts[t[2]]));\u000a",
    "                vector<int> tri = {ord[t[0]], ord[t[1]], ord[t[2]]};\u000a",
    "                sort(all(tri));\u000a",
    "                res.push_back(tri);\u000a",
    "            }\u000a",
    "        }\u000a",
    "        return res;\u000a",
    "    }\u000a",
    "\u000a",
    "    void getVoronoiEdges(vector<vector<int>> triangles) {\u000a",
    "        map<pair<int, int>, vector<Point>> m;\u000a",
    "        for (auto t: triangles) {\u000a",
    "            Point O = center(pts[t[0]], pts[t[1]], pts[t[2]]);\u000a",
    "            m[{ord[t[0]], ord[t[1]]}].push_back(O);\u000a",
    "            m[{ord[t[0]], ord[t[2]]}].push_back(O);\u000a",
    "            m[{ord[t[1]], ord[t[2]]}].push_back(O);\u000a",
    "        }\u000a",
    "        for (auto v: m) {\u000a",
    "            if (v.second.size() == 2) {\u000a",
    "                pair<int, int> u = v.first;\u000a",
    "                if (u.second < u.first) swap(u.first, u.second);\u000a",
    "                if (u.second >= ordPts.size()) {\u000a",
    "                    u.second = -1;\u000a",
    "                    swap(u.first, u.second);\u000a",
    "                }\u000a",
    "                voronoiEdges[u] = {v.second[0], v.second[1]};\u000a",
    "            }\u000a",
    "        }\u000a",
    "    }\u000a",
    "\u000a",
    "    void add_edge(int u, int v) {\u000a",
    "        E[u].insert(v);\u000a",
    "        E[v].insert(u);\u000a",
    "    }\u000a",
    "\u000a",
    "    void remove_edge(int u, int v) {\u000a",
    "        E[u].erase(v);\u000a",
    "        E[v].erase(u);\u000a",
    "    }\u000a",
    "\u000a",
    "    void go(int l, int r) {\u000a",
    "        \u000a",
    "        int n = r - l;\u000a",
    "        if (n <= 3) {\u000a",
    "            for (int i=l; i<r; i++)\u000a",
    "                for (int j=i+1; j<r; j++) add_edge(i, j);\u000a",
    "            if (n == 3 && fabs(cross(pts[l], pts[l + 1], pts[l + 2])) < EPS) { // collinear\u000a",
    "                remove_edge(l, l + 2);\u000a",
    "            }   \u000a",
    "            return;\u000a",
    "        }\u000a",
    "        int md = (l+r)/2;\u000a",
    "\u000a",
    "        go(l, md);\u000a",
    "        go(md, r);\u000a",
    "\u000a",
    "        int il = l, ir = r-1;\u000a",
    "\u000a",
    "        while (1) {\u000a",
    "            int nx = -1;\u000a",
    "            for (auto i: E[il]) {\u000a",
    "                long double cs = cross(pts[il], pts[i], pts[ir]);\u000a",
    "                if (cs > EPS ||\u000a",
    "                    (abs(cs) < EPS and abs(pts[i]-pts[ir]) < abs(pts[il]-pts[ir]))) {\u000a",
    "                    nx = i;\u000a",
    "                    break;\u000a",
    "                }\u000a",
    "            }\u000a",
    "            if (nx != -1) {\u000a",
    "                il = nx;\u000a",
    "                continue;\u000a",
    "            }\u000a",
    "            for (auto i: E[ir]) {\u000a",
    "                long double cs = cross(pts[ir], pts[i], pts[il]);\u000a",
    "                if (cs < -EPS ||\u000a",
    "                    (abs(cs) < EPS and abs(pts[i]-pts[il]) < abs(pts[ir]-pts[il]))) {\u000a",
    "                    nx = i;\u000a",
    "                    break;\u000a",
    "                }\u000a",
    "            }\u000a",
    "\u000a",
    "            if (nx != -1) {\u000a",
    "                ir = nx;\u000a",
    "            } else break;\u000a",
    "        }\u000a",
    "        add_edge(il, ir);\u000a",
    "        \u000a",
    "        while (1) {\u000a",
    "            int nx = -1;\u000a",
    "            bool is2 = false;\u000a",
    "\u000a",
    "            for (int i: E[il]) {\u000a",
    "                if (cross(pts[il], pts[i], pts[ir]) < -EPS and\u000a",
    "                    (nx == -1 or inCircle(pts[il], pts[ir], pts[nx], pts[i]))) nx = i;\u000a",
    "            }\u000a",
    "            for (int i: E[ir]) {\u000a",
    "                if (cross(pts[ir], pts[i], pts[il]) > EPS and\u000a",
    "                    (nx == -1 or inCircle(pts[il], pts[ir], pts[nx], pts[i]))) nx = i, is2 = 1;\u000a",
    "            }\u000a",
    "\u000a",
    "            if (nx == -1) break;\u000a",
    "            int a = il, b = ir;\u000a",
    "            if (is2) swap(a, b);\u000a",
    "\u000a",
    "            vector<int> tmp;\u000a",
    "            for (auto i: E[a]) {\u000a",
    "                if (intersect(pts[a], pts[i], pts[b], pts[nx])) {\u000a",
    "                    tmp.pb(i);\u000a",
    "                } \u000a",
    "            }\u000a",
    "            for (auto i: tmp) {\u000a",
    "                remove_edge(a, i);\u000a",
    "            }\u000a",
    "\u000a",
    "            if (is2) {\u000a",
    "                add_edge(il, nx);\u000a",
    "                ir = nx;\u000a",
    "            } else {\u000a",
    "                add_edge(ir, nx);\u000a",
    "                il = nx;\u000a",
    "            }\u000a",
    "        }\u000a",
    "    }\u000a",
    "\u000a",
    "    // helper functions\u000a",
    "    bool ccw(Point a, Point b) {\u000a",
    "        if (fabs(a.y) < EPS && fabs(b.y) < EPS) return a.x < b.x;\u000a",
    "        return a.x * b.y < a.y * b.x;\u000a",
    "    }\u000a",
    "\u000a",
    "    vector<vector<int>> getTriangles(vector<vector<int>> adj) {\u000a",
    "        vector<vector<int>> res;\u000a",
    "\u000a",
    "        for (int i = 0; i < N; i++) {\u000a",
    "            vector<pair<Point, int>> curPoints;\u000a",
    "\u000a",
    "            for (auto j: adj[i]) {\u000a",
    "                curPoints.push_back({pts[j] - pts[i], j});\u000a",
    "            }\u000a",
    "\u000a",
    "            // angular sort\u000a",
    "            sort(all(curPoints), [&](pair<Point, int> pp1, pair<Point, int> pp2) {\u000a",
    "                Point p1 = pp1.first, p2 = pp2.first;\u000a",
    "                if ((p1.y >= -EPS && p2.y >= -EPS) || (p1.y < 0 && p2.y < 0)) {\u000a",
    "                    return ccw(p1, p2);\u000a",
    "                }\u000a",
    "                return p1.y > p2.y;\u000a",
    "            });\u000a",
    "\u000a",
    "            int n = curPoints.size();\u000a",
    "            \u000a",
    "            FOR (j, 0, n - 1) {\u000a",
    "                int k = (j + 1) % n;\u000a",
    "                int ij = curPoints[j].second, ik = curPoints[k].second;\u000a",
    "\u000a",
    "                if (cross(curPoints[k].first, curPoints[j].first) > EPS) {\u000a",
    "                    vector<int> triangle = {i, ij, ik};\u000a",
    "                    sort(all(triangle));\u000a",
    "                    res.push_back(triangle);\u000a",
    "                }\u000a",
    "            }\u000a",
    "        }\u000a",
    "        sort(all(res));\u000a",
    "        res.erase(unique(all(res)), res.end());\u000a",
    "\u000a",
    "        return res;\u000a",
    "    }\u000a",
    "} tri;\u000a",
    "\u000a",
    "\u000a",
    "// A on [BC]\u000a",
    "bool onSegment(Point A, Point B, Point C) {\u000a",
    "    return fabs(cross(A, B, C)) < eps && (A.x - B.x) * (A.x - C.x) < eps && (A.y - B.y) * (A.y - C.y) < eps;\u000a",
    "}\u000a",
    "\u000a",
    "\u000a",
    "bool inPolygon(vector<Point>& p, Point q) {\u000a",
    "    if (p.size() == 0) return 0;\u000a",
    "    int n = p.size();\u000a",
    "    FOR (i, 0, n - 1) {\u000a",
    "        int j = (i + 1) % n;\u000a",
    "        if (onSegment(q, p[i], p[j])) return 1;\u000a",
    "    }\u000a",
    "    int c = 0;\u000a",
    "    for (int i = 0; i < n; i++) {\u000a",
    "        int j = (i + 1) % n;\u000a",
    "        if ((p[i].y <= q.y && q.y < p[j].y || p[j].y <= q.y && q.y < p[i].y) && q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y)) c = !c;\u000a",
    "    }\u000a",
    "    return c;\u000a",
    "}\u000a",
    "\u000a",
    "long double calc(vector<Point>& p, Point A) {\u000a",
    "    long double res = 1e18;\u000a",
    "    for (auto B: p) {\u000a",
    "        res = min(res, abs(A - B));\u000a",
    "    }\u000a",
    "    return res;\u000a",
    "}\u000a",
    "\u000a",
    "vector<Point> edge[2005][2005];\u000a",
    "\u000a",
    "int main()\u000a",
    "{IN; OUT;\u000a",
    "    ios::sync_with_stdio(0);\u000a",
    "    cin.tie(NULL);\u000a",
    "\u000a",
    "    GD_INIT(\u0022geo.html\u0022);\u000a",
    "    int n;\u000a",
    "    cin >> n;\u000a",
    "    vector<Point> p;\u000a",
    "    FOR (i, 1, n) { \u000a",
    "        Point u;\u000a",
    "        cin >> u.x >> u.y;\u000a",
    "        GD_POINT(u.x, u.y);\u000a",
    "        p.pb(u);\u000a",
    "    }\u000a",
    "\u000a",
    "    vector<Point> candidates;\u000a",
    "    vector<vector<int>> triangles = tri.solve(p);\u000a",
    "    \u000a",
    "    for (auto p: tri.voronoiVertices) {\u000a",
    "        candidates.pb(p);\u000a",
    "    }\u000a",
    "    for (auto i: tri.voronoiEdges) {\u000a",
    "        Point A = i.second.first;\u000a",
    "        Point B = i.second.second;\u000a",
    "        GD_SEGMENT(A.x, A.y, B.x, B.y, \u0022red\u0022);\u000a",
    "\u000a",
    "        FOR (k, 0, n - 1) {\u000a",
    "            Point C = p[k];\u000a",
    "            Point D = p[(k + 1) % n];\u000a",
    "            if (intersect(A, B, C, D)) {\u000a",
    "                Line AB = Line(A, B);\u000a",
    "                Line CD = Line(C, D);\u000a",
    "                Point E;\u000a",
    "                if (areIntersect(AB, CD, E)) {\u000a",
    "                    candidates.push_back(E);\u000a",
    "                }\u000a",
    "            }\u000a",
    "        }\u000a",
    "    }\u000a",
    "\u000a",
    "    long double res = 0;\u000a",
    "    for (auto c: candidates) {\u000a",
    "        if (inPolygon(p, c)) {\u000a",
    "            res = max(res, calc(p, c));\u000a",
    "        }\u000a",
    "    }\u000a",
    "\u000a",
    "    cout << fixed << setprecision(10) << res << endl;\u000a",
    "\u000a",
    "\u000a",
    "    return 0;   \u000a",
    "}"
  ],
  "root": {
    "type": "begin",
    "line": 374,
    "children": [
      {
        "type": "point",
        "line": 381,
        "x": 10000.000000,
        "y": 10000.000000
      },
      {
        "type": "point",
        "line": 381,
        "x": -10000.000000,
        "y": 10000.000000
      },
      {
        "type": "point",
        "line": 381,
        "x": 10000.000000,
        "y": 9999.000000
      },
      {
        "type": "segment",
        "line": 394,
        "x1": 0.000000,
        "y1": 30000.000000,
        "x2": 0.000000,
        "y2": 30000.000000,
        "attr": "red"
      },
      {
        "type": "segment",
        "line": 394,
        "x1": -30000.000000,
        "y1": 0.000000,
        "x2": 0.000000,
        "y2": 30000.000000,
        "attr": "red"
      },
      {
        "type": "segment",
        "line": 394,
        "x1": -0.999958,
        "y1": -9999.666681,
        "x2": 0.000000,
        "y2": -10000.666672,
        "attr": "red"
      },
      {
        "type": "segment",
        "line": 394,
        "x1": 0.000000,
        "y1": 30000.000000,
        "x2": 0.000000,
        "y2": 9999.500000,
        "attr": "red"
      },
      {
        "type": "segment",
        "line": 394,
        "x1": 0.000000,
        "y1": 9999.500000,
        "x2": 20000.500000,
        "y2": 9999.500000,
        "attr": "red"
      },
      {
        "type": "segment",
        "line": 394,
        "x1": -0.999958,
        "y1": -9999.666681,
        "x2": 0.000000,
        "y2": 9999.500000,
        "attr": "red"
      }
    ]
  },
  "theme": "light"
};
init(resourcePath);
</script>
</html>
